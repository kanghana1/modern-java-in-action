# Chapter 1 - 자바 8,9,10,11: 무슨일이 일어나고 있는가?

제가 파악한 해당 챕터의 대주제는 다음과 같습니다.

- 자바의 역사와 변화
- 자바 8,9의 기능 (스트림, 디폴트메소드)
- 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

지금부터 위 목차를 위주로 정리해 보려고 합니다.
<br>
<br>

## ■ 1,2. 자바의 흐름과 변화

## □ 자바의 역사와 변화

모든 프로그래밍 언어들은 시간이 지남에 따라 크고 작은 변화를 겪었고, 자바 또한 마찬가지였습니다.
1996년에 발표된 자바는 변화를 반복하였고 2018년 자바11이 릴리즈 되었습니다.
<br>

자바 역사를 통틀어 가장 큰 변화가 일어난 것은 자바8이 나왔을 때입니다. 물론 자바9도 중요한 변화를 가져왔지만, **자바 8**에서 획기적인 변화가 있었습니다.

  <br>
  자바8이 나오기 전, 멀티코어 CPU 대중화 같은 하드웨어적인 변화가 있었습니다. 대다수의 데스크톱에는 듀얼/쿼드 코어 이상을 지원하는 CPU가 내장되어 있는데 자바는 대부분 단 하나의 코어를 사용했습니다. 그래서 나머지 코어를 사용하기 위해 고민했던 것입니다.
<br><br>

그에 대한 방법으로 스레드를 사용하는 것이 좋다고 조언했을 것이라 하지만, 스레드를 사용하면 관리가 어렵고, 많은 문제를 발생시킨다는 문제점이 있었습니다. 이런 문제를 해결하기 위한 움직임은 자바8 이전에도 있었지만, 개발자가 활용하기에는 어려움이 있었습니다. <br>

<span style="color: grey">+ 자바 8 이전 움직임</span>

- <span style="color: grey">자바 1.0 -> _스레드, 락, 메모리모델 지원_
- <span style="color: grey">자바 5 -> _스레드 풀, 병렬시행 컬렉션 도입_
- <span style="color: grey"> 자바 7 -> _포크/조인 프레임워크_

<br>

자바8에서는 _**간결한 코드, 멀티코어 프로세서의 쉬운 활용**_ 을 기반으로 병렬시행을 새롭고 단순한 방식으로 접근할 수 있도록 합니다.
<br>
이런 자바8의 메소드는 다음과 같습니다.<br>

- 스트림 API (병렬 연산 지원)
- 메소드에 코드를 전달하는 기법
- 인터페이스의 디폴트 메소드

<br>

#### **언어의 생테계, 자바의 위치**

1960년대부터 사람들은 완벽한 프로그래밍 언어를 얻기 위해 수많은 프로그래밍 언어들을 개발하였고, 그 과정에서 프로그래밍 언어가 생태계와 닮았다는 결론을 내렸습니다.

수많은 언어중 현실적으로 완벽한 언어는 존재하지 않았고, 각 언어들은 장단점을 갖고 있었습니다. 임베디드 시스템에 특화된 C,C++처럼 특정 분야에서 장점을 가진 언어는 다른 경쟁언어를 도태시킵니다.

자바 또한 마찬가지로 수많은 경쟁언어를 대신하며 커다란 생태계를 구축했다고 합니다.

 <br>

### ▷ 자바는...

- 수많은 유용한 라이브러리 제공
- 잘 설계된 객체지향 언어
- 소소한 동시성 지원
- JVM 바이트코드로 컴파일

하지만 빅데이터라는 분야에 직면하면서 병렬 프로세싱을 활용해야 했지만 자바로는 충분하지 못했습니다.

그래서 자바8은 다음에 설명할 메소드를 이용해 다양한 프로그래밍 문제를 빠르고 정확히 해결할 수 있게 지원한다고 합니다.
<br>
<br>

## □ 자바8의 메소드

### **1. <span style="background-color: #380B61">스트림 API**

스트림이란, 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임입니다. 스트림은 입력스트림과 출력스트림으로 나뉘며, 입력 스트림에서 데이터를 한 개씩 읽어들이고 마찬가지로 출력스트림에서 데이터를 한 개씩 기록합니다.

즉, 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있습니다.

일례로 유닉스에서는 파이프(|) 를 이용해 위 설명처럼 명령을 병렬처리 합니다.

```c
cat file1 file2 | tr "[A-Z]" "[a-z]" | sort | tail -3
```

sort는 여러 행의 스트림을 입력으로 받고, 여려 행의 스트림을 출력 즉 병렬 시행합니다.

이러한 이유로 cat이나 tr이 완료되지 않은 시점에서 sort가 행을 처리할 수 있습니다.

- java.util.stream 패키지에 스트림 API가 추가되어있습니다.
- 스트림API가 조립 라인처럼 어떤 항목을 연속으로 제공하는 기능이라고 생각하면 됩니다.
- 스트림 API는 파이프라인을 만드는 데 필요한 메소드를 제공합니다.

> 핵심은 한 번에 한 항목을 처리한 기존과는 다르게 자바 8에서는 우리가 하려는 작업을 고수준으로 추상화 해 <span style="color: pink">일련의 스트림</span>으로 만들어 처리할 수 있으며, 스트림 파이프라인을 이용해 입력 부분을 여러 CPU코어에 쉽게 할당할 수 있다는 것입니다.

<br>
+)

데이터베이스 질의 언어에서 **고수준 언어**로 원하는 동작을 표현하면, 구현에서 최적의 **저수준 실행 방법**을 선택하는 방식으로 동작한다고 합니다.<br>

=> 즉, 스트림을 이용하면 에러를 자주 일으키며 멀티코어 CPU를 이용하는 것 보다 비용이 훨씬 비싼 키워드 synchronized를 사용하지 않아도 됩니다.

> 즉, 자바8에 추가된 스트림 API 덕에 다른 두 가지 기능인 메소드에 코드를 전달하는 간결한 기법과 인터페이스의 디폴트 메소드가 존재할 수 있음을 알 수 있습니다.

하지만 스트림 API때문에 메소드에 코드 전달하는 기법이 생겼다고 생각하는 건 위험하다고 합니다.
<br><br>

### **2.<span style="background-color: #380B61"> 메소드에 코드를 전달하는 기법 - 동작파라미터화**

이 메소드는 코드 일부를 API로 전달하는 기능을 하며, _메소드에 코드를 전달_ 하는 기법을 이용하면 새롭고 간결한 방식으로 **동작 파라미터화**를 구현할 수 있습니다.

메소드를 다른 메소드로 전달할 수 없었던 이전과는 달리 **메소드를 다른 메소드의 인수로 넘겨주는 기능**을 제공하는데 이를 **동작 파라미터화** 라고 부릅니다.

동작파라미터화가 중요한 이유는 스트림 API 자체가 연산의 동작을 파라미터화 할 수 있는 코드를 전달한다는 사상에 기초하기 때문입니다.

> 이런 기법은 함수형 프로그래밍에서 위력을 발휘합니다.

<br>

### **3. <span style="background-color: #380B61">병렬성과 공유 가변 데이터**

자바8에서 병렬성을 얻은 대신 코드의 동작 방식을 조금 바꾸었습니다.

병렬적으로 실행함과 동시에 안전하게 실행되기 위해서는, **공유된 가변 데이터에 접근하지 않아야** 합니다. 이런 함수를 순수함수, 부작용 없는 함수, 상태 없는 함수라고 부릅니다.

하지만 공유된 변수나 객체가 있으면 병렬성에 문제가 발생합니다. 기존처럼 synchronized를 이용하여 공유된 가변 데이터를 보호하는 규칙을 사용할 수도 있지만, 자바8 스트림을 사용하면 기존의 자바 스레드보다 쉽게 병렬성을 활용할 수 있습니다.

- **공유되지 않은 가변 데이터, 메소드, 함수 코드를 다른 메소드로 전달하는 두 가지 기능은 함수형 프로그래밍 패러타임의 핵심사항**입니다.
- 반면 명령형 프로그래밍 패러다임에서는 일련의 가변 상태로 프로그램을 정의합니다.

### **4. <span style="background-color: #380B61">자바가 진화해야 하는 이유**

for-each 루프를 사용할 수 있게 되는 등 기존 값을 변화시키는 데 집중했던 고전적인 객체지향에서 벗어나 **함수형 프로그래밍**으로 다가섰다는 것이 자바8의 가장 큰 변화라고 합니다.

#### **▷ 함수형 프로그래밍에서는...**

- 우리가 하려는 작업을 최우선시
- 어떻게 수행하는지는 별개의 문제

자바8에서 함수형 프로그래밍을 도입함으로써 서로 상극인 전통 객체지향 프로그래밍과 함수형 프로그래밍의 장점을 모두 활용할 수 있게 되었습니다.

이렇게 언어는 하드웨어나 프로그래머 기대의 변화에 부응하는 방향으로 변화해야 자리를 유지하고 살아남을 수 있습니다. 이런 이유로 자바는 앞으로도 진화해야 한다고 합니다.
<br>
<br>

<hr>

## ■ 3. 자바함수

프로그래밍 언어에서 함수라는 용어는 메소드 특히 정적 메소드와 같은 의미로 사용됩니다.

자바에서의 함수는 이에 더해 **수학적인 함수**처럼 사용되며, 부작용을 일으키지 않는 함수를 의미합니다. 자바 8에서의 함수 사용법은 일반적인 프로그래밍 언어의 함수 사용법과 비슷합니다.

자바의 스트림과 연계될 수 있도록 함수를 만들었기 때문에, 함수를 값처럼 취급할 수 있게 되었습니다.

#### ▷ 자바 프로그램에서 조작할 수 있는 값

- 기본값 (int, double, etc.)
- 객체의 참조 (클래스의 인스턴스)

배열도 객체인데 왜 굳이 함수가 필요할까요?
<br>
<br>

### **1.<span style="background-color: #380B61"> 프로그래밍 언어의 핵심은 값을 바꾸는 것!**

- 역사적, 전통적으로 프로그래밍 언어에서는 "값"을 <span style="color: pink">일급값</span>이라고 불렀습니다.
- 구조체처럼 모든 구조체를 자유롭게 전달할 수 없는 값을 <span style="color: pink">이급시민</span>이라고 합니다.

뿐만 아니라 메소드, 클래스도 마찬가지로 이급 자바 시민에 해당됩니다. 즉, 메소드와 클래스는 그 값으로 값이 될 수 없는 것입니다.

만약 값이 될 수 있다면, 프로그래밍에 유용하게 활용할 수 있을 것이라고 생각한 설계자들은 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가했다고 합니다.

### **2.<span style="background-color: #380B61"> 메소드와 람다를 일급 시민으로!**

일급값의 유용성은 이미 스칼라와 그루비 등의 언어로 증명되었습니다. 이러한 강력한 기능에 익숙해지면, 일급 시민이 부족한 다른 언어를 기피하는 현상까지 발생할 수 있어 자바 8의 설계자들은 메소드를 값으로 취급할 수 있도록 설계하였습니다. 기능을 살펴보면 아래와 같습니다.

#### **▷ 메소드 참조**

디렉토리에서 모든 숨겨진 파일을 필터링 한다고 가정해보면 아래와 같은 코드를 작성할 수 있습니다.
아래 코드는 FileFilter 객체 내부에 위치한 isGidden의 결과를 File.listFiles 메소드로 전달합니다.

```java
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
  public boolean accept(File file){
    return file.isHidden(); //숨겨진 파일 핕터링
  }
});
```

하지만 이 코드는 각각이 어떤 역할을 하는지 알기 어렵고 복잡합니다. 자바8에서는 아래처럼 더 간단하게 구현이 가능합니다.

```java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

- :: -> 메소드 참조 (이 메소드를 값으로 이용하라는 의미)

이를 이용해 listFiles에 직접 전달할 수 있습니다. 기존에 객체참조를 이용해 객체를 주고받았듯이, 메소드 참조를 만들어 전달할 수 있게 된 것입니다.

#### **▷ 람다 : 익명함수**

자바8에서는 메소드를 일급값으로 취급할 뿐만 아니라 **람다**를 포함하여 함수도 값으로 취급할 수 있습니다.

<span style="color: lightblue"> ex | (int x) -> x + 1 (x호출 시 x+1 반환)</span>

메소드를 직접 정의할 수 있지만, 이용할 수 있는 편리한 클래스나 메소드가 없을 때 새로운 람다 문법을 이용해 더 간결하게 코드를 구현할 수 있습니다.

이렇게 람다 문법 형식으로 구현된 프로그램을 **함수형 프로그래밍**, 즉 _'함수를 일급값으로 넘겨주는 프로그램을 구현한다'_ 라고 합니다.

### **3.<span style="background-color: #380B61"> 코드 넘겨주기 : 예제**

Apple 클래스와 getColor 메서드가 있고, Apples 리스트를 포함하는 변수 inventory가 있다고 가정할 떄, 모든 녹색 사과를 선택해서 리스트를 반환하는 프로그램을 구현하려고 합니다. 이처럼 특정 항목을 선택해서 반환하는 동작을 <span style="color: pink"> **필터(filter)** </span>라고 합니다.

- 자바8 이전

사과의 색을 기준으로 필터링하는 경우

```java
public static List<Apple> filterGreenApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if ("green".equals(apple.getColor())) {
        result.add(apple);
      }
    }
    return result;
}
```

사과의 무게를 기준으로 필터링하는 경우

```java
public static List<Apple> filterHeavyApples(List<Apple> inventory) {
	List<Apple> result = new ArrayList<>();
	for (Apple apple: inventory) {
		if (apple.getWeight() > 150){
			result.add(apple);
		}
	}
	return result;
}
```

소프트웨어공학적인 면에서 복사/붙여넣기를 한 어떤 코드에 버그가 있으면 복사/붙여넣기 한 모든 코드를 고쳐야 한다는 단점이 있습니다.

자바8은 코드를 인수로 넘겨줄 수 있어 filter 메서드를 중복으로 구현할 필요가 없습니다. 앞의 코드를 자바8에 맞게 구현하면 아래와 같습니다.

```java
public static boolean isGreenApple(Apple apple){
	return GREEN.equals(apple.getColor());
}
public static boolean isHeavyApple(Apple apple){
	return apple.getWeight() > 150;
}
public interface Predicate<T>{   //명확히 하기 위해 추가함 (보통 java.util.function에서 임포트 함)
	boolean test(T, t);
}

static List<Apple> filterApples(List <Apple> inventory, Predicate<Apple> p){
	List<Apple> result = new ArrayList<>();
	for (Apple apple : inventory){
		if (p.test(apple)){
			result.add(apple);
		}
	}
	return result;
}
```

다음과 같이 호출할 수 있습니다.

```java
filterApples(inventory, Apple::isGreenApple);
filterApples(inventory, Apple::isHeavyAplle);
```

> 프레디케이트(predicate)란 무엇인가?
>
> 앞서 다룬 예제에서는 Apple::isGreenApple 메소드를 filterApples로 넘겨주었는데, 이와 같이 수학에서는 인수로 값을 받아 true나 flase를 반환하는 함수를 프레디케이트라고 한다.
>
> - Function<Apple, Boolean> 이렇게 구현 가능
> - Predicate<Apple> 이렇게 쓰는게 더 표준

### **4.<span style="background-color: #380B61"> 메소드 전달에서 람다로**

메소드를 값으로 전달하는 것이 유용한 기능이라는 것은 맞지만, 한 두번만 사용할 메소드까지 매번 정의하는 것은 비효율적일 수 있습니다! 자바 8에서는 아래처럼 람다를 사용해 이러한 문제도 해결할 수 있습니다.

```java
filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()));
fliterApples(inventory, (Apple a) -> a.getWeight() > 150);
// 심지어 이렇게도 구현가능하다
filterApples(inventory, (Apple a) -> a.getWeight() > 150 || GREEN.equals(a.getColor()));
```

즉, 한 번만 사용할 메소드는 따로 구현할 필요 없이 위처럼 작성이 가능합니다.
하지만 람다 식이 몇 줄 이상으로 길어진다면, _**코드의 명확성**_ 을 위해 메소드를 정의하고 참조를 활용하는게 좋습니다.

멀티코어 CPU 덕분에 자바8 설계자들의 계획은 위 내용들보다 더 뻗어나갈 수 있었습니다. 자바는 filter, 다른 일반적은 라이브러리 메소드를 추가하는 방향으로 발전하려고 했다고 합니다.

```java
static <T> Collection<T> filter(Collection<T> c, Predicate<T> p);
```

예를 들어 이전 메소드에서는 다음처럼 filterApples 를 사용했지만,

```java
filterApples(inventory, (Apple a) -> a.getWeight() > 150);
```

다음처럼 라이브러리 메소드 filter를 이용하면 굳이 filterApples를 구현하지 않아도 됩니다.

```java
filter(inventory, (Apple a) -> a.getWeight() > 150);
```

하지만 **병렬성**이라는 중요성 때문에 이와 같은 설계를 포기했습니다. 대신 자바 8에서 filter와 비슷한 동작을 수행하는 새로운 스트림 API를 제공합니다.

<br>
<hr>

## ■ 4. 스트림

거의 모든 자바 애플리케이션은 컬렉션을 만들고 활용하지만, 컬렉션으로 모든 문제가 해결되지는 않습니다.

- 많은 기본 코드를 구현해야 한다는 점
- 중첩된 제어 흐름 문장이 많아 코드를 한 번에 이해하기 점

이러한 컬렉션의 문제점은 <span style="color: pink">**스트림 API**</span>를 이용하면 해결할 수 있습니다.

스트림 API를 이용하면 컬렉션 API와는 다른 방식으로 데이터를 처리할 수 있다고 합니다.

<br>

**▷ 컬렉션 API 처리 <span style="color: pink">(외부 반복)**

> 반복 과정을 for-each 루프를 통해 각 요소를 반복하여 직접 처리해야 했습니다.
>
> -> 리스트가 거대해지면 시간이 오래걸린다는 단점이 있습니다.

**▷ 스트림 API 처리 <span style="color: pink">(내부 반복)**

> 루프를 신경 쓸 필요 없이 라이브러리 내부에서 모든 데이터가 처리됩니다.

<br>

### **1.<span style="background-color: #380B61"> 멀티스레딩은 어렵다**

이전 자바 버전에서 제공하는 스레드 API로 멀티스레딩 코드를 구현해서 병렬성을 이용하기는 쉽지 않았습니다.

멀티스레딩 환경에서 각각의 스레드는 동시에 공유된 데이터에 접근하고, 데이터를 갱신할 수 있으나 결과적으로 잘 제어하지 못하면 원치 않는 방식으로 데이터가 바뀔 수 있다는 문제가 있었습니다.

자바8은 스트림 API (java.util.Stream) 으로

1. 컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제
2. 멀티코어 활용 어려움

이상 두 가지 문제를 모두 해결하였습니다.

<br>

▷ 첫번째 문제인 **모호함과 반복적인 코드 문제**는 라이브러리에서 반복되는 패턴을 제공하면 좋을 것이라는 아이디어를 동기로

1. 주어진 조건에 따라 데이터를 필터링
2. 데이터 추출
3. 데이터 그룹화

위와 같은 메소드를 제공하여 해결했습니다.

<br>
▷ 두번째 문제 또한 위와 같은 동작들을 쉽게 병렬화 할 수 있다는 점을 동기로

1. 두 CPU를 가진 환경에서 앞뒤 부분을 각각 맡아 처리해달라는 요청 (포킹단계)
2. 각각의 CPU는 자신이 맡은 절반의 리스트 처리
3. 하나의 CPU가 두 결과 정리

위와 같은 동작과정으로 해결했습니다.

지금은 새로운 스트림 API도 기존의 컬렉션 API와 아주 비슷한 방식으로 동작한다고 간주합니다. 하지만 다음과 같은 차이는 존재합니다.

- 컬레션 API -> **어떻게 데이터를 저장하고 접근** 할지에 중점
- 스트림 API -> **어떤 계산을 할 것인지 묘사**하는 것에 중점

> 결국 스트림은 스트림 내의 요소를 쉽게 병렬로 처리할 수 있는 환경을 제공다는 것이 핵심!

다음은 순차 처리 방식과 병렬 처리 방식의 코드입니다.

```java
List<Apple> heavyApples = inventory.**stream()**.filter((Apple a)-> a.getWeight() > 150).collect(toList());

List<Apple> heavyApples = inventory.**parallelStream()**.filter((Apple a) -> a.getWeight() > 150).collect(toList());
```

> 자바의 병렬성과 공유되지 않은 가변 상태
>
> - 라이브러리에서 분할처리 => 큰 스트림을 병렬로 처리할 수 있게 작은 스트림으로 분할
>
> - 함수형프로그래밍에서 함수형은 '함수를 일급값으로 사용한다' 라는 의미와 동시에 '프로그램이 실행되는 동안 컴포넌트 간 상호작용 없음' 이라는 의미

<br>
<hr>

## ■ 5. 디폴트 메소드와 자바 모듈

자바 변화 과정에서 자바 8 개발자들이 겪는 어려움 중 하나는 기존 인터페이스의 변경입니다. 요즘은 외부에서 만들어진 컴포넌트를 이용해 시스템을 구축하는데, 지금까지 자바에서는 특별한 구조가 아닌 평범한 자바 패키지 집합을 포함하는 JAR 파일을 제공하는 게 전부였습니다.

이런 상황에서 패키지의 인터페이스를 바꾸려면 인터페이스를 구현하는 모든 클래스의 구현을 바꿔야 하므로 너무 힘든 작업이었습니다.

이러한 문제를 자바8,9 에서는 다른 방법으로 해결합니다.

**▷ 자바 9**

모듈을 정의하는 문법을 제공하므로 이를 이용해 패키지 모음을 포함하는 모듈을 정의할 수 있습니다. 덕분에 JAR같은 컴포넌트에 구조를 적용할 수 있으며, 문서화와 모듈 확인 작업이 용이해졌습니다.

**▷ 자바 8**

인터페이스를 쉽게 바꿀 수 있도록 <span style="color: pink">**디폴트 메소드**</span>를 지원합니다.

(디폴트 메소드를 직접 구현하는 상황은 거의 없다고 합니다)

디폴트 메서드는 특정 프로그램을 구현하는 데 도움을 주는 기능이 아니라 미래에 프로그램이 쉽게 변화할 수 있는 환경을 제공하는 기능을 합니다.

<br>

```java
List<Apple> heavyApples = inventory.**stream()**.filter((Apple a)-> a.getWeight() > 150).collect(toList());

List<Apple> heavyApples = inventory.**parallelStream()**.filter((Apple a) -> a.getWeight() > 150).collect(toList());
```

자바 8 이전에는 List가 stream이나 parallelStream 메서드를 지원하지 않아 컴파일을 할 수 없는 고드입니다.

간단한 해결책은 직접 인터페이스를 만들어 Collection 인터페이스에 stream 메소드를 추가해 ArrayList 클래스에서 메소드를 구현하는 것입니다.

하지만 이미 컬렉션 API의 인터페이스를 구현하는 많은 컬렉션 프레임워크가 존재해 직접 구현해야 합니다. 그러나 언어 설계자들이 모든 코드를 책임질 수 없기 때문에 기존의 구현을 고치지 않고 이미 공개된 인터페이스를 변경할 수 있는 방법을 찾았다고 합니다.

그 방법이 바로 위에 말한 <span style="color: pink">**디폴트 메소드 !!**</span> 입니다.

( 메서드 본문은 클래스 구현이 아니라 인터페이스의 일부로 포함됩니다. 그래서 이를 디폴트 메서드라고 부릅니다. )

<br>
<hr>

## ■ 6. 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

자바에 포함된 함수형 프로그래밍의 핵심 아이디어는

- 메소드와 람다를 일급값으로 사용
- 가변 공유 상태가 없는 병렬 실행

이고, 스트림 API는 이 두가지 아이디어를 모두 활용합니다.

일반적인 함수형 언어도 프로그램을 돕는 여러 장치를 제공합니다. 예를 들면 서술형의 데이터 형식을 이용해 null을 회피하는 기법이 있습니다.

자바 8에서는 **NullPointer 예외를 피하게 해주는** **Optional<T> 클래스**를 제공합니다.
Optional<T>는 값을 갖거나 갖지 않을 수 있는 컨테이너 객체입니다. 이는 값이 없는 상황에 대한 처리방법이 구현되어 있어 NullPointer 예외를 피할 수 있습니다.

이외에도 (구조적)패턴 매칭 기법도 있습니다. 자바에서는 if-then-else나 switch문을 이용하지만 다른 언어에서는 패턴 매칭으로 더 정확한 비교를 구현할 수 있다는 사실을 증명했습니다. 아쉽게도 자바8은 패턴매칭을 완벽히 지원하지 않습니다.

<br>
<hr>

## ■ 7. 마치며

- 언어 생태계의 모든 언어는 변화해서 살아남거나 그대로 머물면서 사라지게 된다. 지금은 자바의 위치가 견고하지만 코볼과 같은 언어의 선례를 떠올리면 자바가 영원히 지배적인 위치를 유지할 수 있는 것은 아닐 수 있다.
- 자바 8은 프로그램을 더 효과적이고 간결하게 구현할 수 있는 새로운 개념과 기능을 제공한다.
- 기존의 자바 프로그래밍 기법으로는, 멀티코어 프로세서를 온전히 활용하기 어렵다.
- 함수는 일급 값이다. <span style="color: pink">메서드를 어떻게 함수형값으로 넘겨주는지, 익명 함수(람다)를 어떻게 구현하는지</span> 기억하자
- 자바 8의 <span style="color: pink">스트림 개념</span> 중 일부는 컬렉션에서 가져온 것이다, 스트림과 컬렉션을 적절하게 활용하면 스트림의 인수를 병렬로 처리할 수 있으며 더 가독성이 좋은 코드를 구현할 수있다.
- 기존 자바 기능으로는 대규모 컴포넌트 기반 프로그래밍 그리고 진화하는 시스템의 인터페이스를 적절하게 대응하기 어려웠다, <span style="color: pink">디폴트 메서드</span>를 이용해 기존 인터페이스를 구현하는 클래스를 바꾸지 않고도 인터페이스를 변경할 수 있다!
- 함수형 프로그래밍에서 NULL 처리 방법과 패턴 매칭 활용 등 흥미로운 기법을 발견했다.
